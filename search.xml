<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java</title>
    <url>/2020/05/20/Java/</url>
    <content><![CDATA[<h4 id="volatile修饰"><a href="#volatile修饰" class="headerlink" title="volatile修饰"></a>volatile修饰</h4><blockquote>
<p>变量声明了volatile后，跳过cpu cache步骤，jvm保证每次直接从内存中读取变量</p>
</blockquote>
<ul>
<li>volatile声明的变量所有线程可见，即当修改一个变量值会立即更新直接更新内存，读取是也直接从内存中刷新读取</li>
<li>volatile声明的变量禁止指令重排序优化</li>
</ul>
<h4 id="volatile性能"><a href="#volatile性能" class="headerlink" title="volatile性能"></a>volatile性能</h4><blockquote>
<p>volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>JMM</title>
    <url>/2020/05/19/JMM/</url>
    <content><![CDATA[<h1 id="Java内存模型（Java-Memory-Model）"><a href="#Java内存模型（Java-Memory-Model）" class="headerlink" title="Java内存模型（Java Memory Model）"></a>Java内存模型（Java Memory Model）</h1><p>屏蔽各种硬件和操作系统的内存访问差异,以便Java在各个平台下内存访问一致</p>
]]></content>
  </entry>
  <entry>
    <title>二分法查找</title>
    <url>/2020/06/07/alg-binary/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote>
<p>二分法查找：又称折半查找。适用于有序数据集合的目标值查找。</p>
</blockquote>
<pre><code>二分法思想：假设有一个按升序排好序的数列data，查找目标值target，过程如下：
1.将数列进行折半，判断data[mid]是否等于target, 相等则返回index, 否则，判断中间值和target大小；
2.若 target &gt; data[mid]，将data右一半执行第一步，否则，将data左一半执行第一步；
3.返回index</code></pre><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>废话不多说，上代码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">BinarySearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> getIndex(<span class="built_in">int</span>[] data, <span class="built_in">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> right = data.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">//定义一个中间值索引</span></span><br><span class="line">            <span class="built_in">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] == target) &#123;</span><br><span class="line">                <span class="comment">//查到目标值，直接返回索引值</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的左半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束，未找到target，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h3><blockquote>
<p>假如数列中出现了重复项，那我们查到的index便不确定，那如何在重复项得到最小的一个位置呢？</p>
</blockquote>
<h4 id="二分查找-顺序查找"><a href="#二分查找-顺序查找" class="headerlink" title="二分查找 + 顺序查找"></a>二分查找 + 顺序查找</h4><figure class="highlight stan"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">int</span> getRepeatIndex(<span class="keyword">int</span>[] <span class="title">data</span>, <span class="keyword">int</span> <span class="built_in">target</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="title">data</span>.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//这里做一改变</span></span><br><span class="line">            <span class="comment">//如果定位到目标值，不立即返回，顺序查找到最靠前的一个</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="title">data</span>[mid] == <span class="built_in">target</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (mid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="title">data</span>[mid] != <span class="built_in">target</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mid --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//循环时多-1，返回时加上</span></span><br><span class="line">                <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="title">data</span>[mid] &lt; <span class="built_in">target</span>) &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的左半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果可以找到，left则为对应的索引值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title">data</span>[left] == <span class="built_in">target</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="二分法到底"><a href="#二分法到底" class="headerlink" title="二分法到底"></a>二分法到底</h4><blockquote>
<p>可能大多数考虑到上述的情况就结束了，仔细想想，还可不可以更快一点儿呢，回答是肯定的</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> getRepeatIndex(<span class="built_in">int</span>[] data, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> right = data.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果数组空直接返回，防止数组越界</span></span><br><span class="line">        <span class="keyword">if</span>(data.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//'&lt;'不是'&lt;=',如果等于会出现死循环</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//关键部位！！！</span></span><br><span class="line">            <span class="comment">//保持要查到的值始终是最小索引的，二分查比顺序查要快</span></span><br><span class="line">            <span class="keyword">if</span>(data[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果可以找到，left则为对应的索引值</span></span><br><span class="line">        <span class="keyword">if</span>(data[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>链表逆置</title>
    <url>/2020/06/12/alg-reverse-list/</url>
    <content><![CDATA[<h3 id="链表逆置"><a href="#链表逆置" class="headerlink" title="链表逆置"></a>链表逆置</h3><blockquote>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
</blockquote>
<p>示例：</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
</blockquote>
<h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><blockquote>
<p>头插法简单明了 <a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">code</a></p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        int val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(int x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode getReverseList(ListNode head) &#123;</span><br><span class="line">        <span class="comment">//定义一个空的头节点</span></span><br><span class="line">        ListNode <span class="keyword">new</span><span class="type">List</span> = <span class="keyword">new</span> <span class="type">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//定一个临时指针，指向下一个节点</span></span><br><span class="line">            ListNode nextNode = head.next;</span><br><span class="line">            <span class="comment">//断开当前节点与下一个节点连接，并接到新链表的前面</span></span><br><span class="line">            head.next = <span class="keyword">new</span><span class="type">List</span>.next;</span><br><span class="line">            <span class="comment">//当前节点插入到头节点之后（头插法）</span></span><br><span class="line">            <span class="keyword">new</span><span class="type">List</span>.next = head;</span><br><span class="line">            <span class="comment">//当前节点向后移</span></span><br><span class="line">            head = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span><span class="type">List</span>.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>整数反转</title>
    <url>/2020/06/13/alg-reverse-integer/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">力扣</a></p>
<blockquote>
<p>Given a 32-bit signed integer, reverse digits of an integer.<br>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p>整数反转当然容易，但是要注意的是32位，溢出问题怎么处理？这里提供三种方式：<strong>String</strong>、<strong>Long</strong>、<strong>Int</strong>(<strong><em>推荐</em></strong>)</p>
</blockquote>
<h3 id="方法一：String"><a href="#方法一：String" class="headerlink" title="方法一：String"></a>方法一：String</h3><blockquote>
<p>利用StringBuffer 的reverse()方法，进行逆置</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public <span class="built_in">int</span> reverse(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="comment">//非负数标记，false为负数</span></span><br><span class="line">        boolean flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果x为-2147483648，-x超过Integer.MAX_VALUE</span></span><br><span class="line">            <span class="keyword">if</span>(x<span class="operator"> == </span>Integer.MIN_VALUE) &#123;</span><br><span class="line">                return <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            x = -x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果为负数，加-号</span></span><br><span class="line">        String str = flag ? <span class="keyword">new</span> <span class="constructor">StringBuffer(String.<span class="params">valueOf</span>(<span class="params">x</span>)</span>).reverse<span class="literal">()</span>.<span class="keyword">to</span><span class="constructor">String()</span> : <span class="string">"-"</span> + <span class="keyword">new</span> <span class="constructor">StringBuffer(String.<span class="params">valueOf</span>(<span class="params">x</span>)</span>).reverse<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否超过Integer值范围</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Long</span>.</span></span>value<span class="constructor">Of(<span class="params">str</span>)</span> &gt; Integer.MAX_VALUE<span class="operator"> || </span><span class="module-access"><span class="module"><span class="identifier">Long</span>.</span></span>value<span class="constructor">Of(<span class="params">str</span>)</span> &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            return <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(<span class="params">str</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：Long"><a href="#方法二：Long" class="headerlink" title="方法二：Long"></a>方法二：Long</h3><blockquote>
<p>用Long值存下,对long值进行反转，最后再判断范围</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> reverse(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        Long result = <span class="number">0</span>L;</span><br><span class="line">        <span class="comment">//不断的取x的最后一位，加到result后面</span></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            result = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否超过Integer值范围</span></span><br><span class="line">        <span class="keyword">if</span>(result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">int</span>Value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：Int"><a href="#方法三：Int" class="headerlink" title="方法三：Int"></a>方法三：Int</h3><blockquote>
<p>以上两种方法都可以很好的解决这个问题，但是我们反思一下，或者我们来强制的加个条件，如果在运行中只能使用32位的整数，该怎么办呢？虽然现在的内存已经不宝贵了，但是我们还是要爱惜一下嘛～<br>那么更好的方法来了，这个题的关键就是输入值x在反转的过程中可能会超过int值的范围，那我们在循环的取数的时候，每次去判断下一个值是否会超过int的范围，这不就OK了</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> reverse(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//不断的取x的最后一位，加到result后面</span></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//判断是否超过Integer值范围</span></span><br><span class="line">            <span class="keyword">if</span>(result &gt; Integer.MAX_VALUE / <span class="number">10</span> || (result == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(result &lt; Integer.MIN_VALUE / <span class="number">10</span> || (result == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; Integer.MIN_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
</search>
