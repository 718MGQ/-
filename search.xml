<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>三次握手、四次挥手</title>
      <link href="/2020/06/14/net-three-and-four/"/>
      <url>/2020/06/14/net-three-and-four/</url>
      
        <content type="html"><![CDATA[<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><blockquote><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接，客户端和服务器端是相对的概念，本文我们以客户端向服务器端发送为例。</p></blockquote><blockquote><p><strong>第一次握手：客户端向服务器端发送一个SYN报文，报文中包含了一个动态生成的序列号i（至于为什么动态生成可以自己想想），这时，客户端处于SYN_SEND状态（打开一个连接），表示已向服务器发送了连接请求；</strong></p></blockquote><blockquote><p><strong>第二次握手：服务器端接收到连接请求，认为可以建起连接，回发一个ACK确认报文，内容将序列号i+1,同时，生成一个序列号j，发送一个SYN报文，内容为序列号j，服务器端处于SYN_REVD状态（连接请求已到达，等待确认），表示等待客户端确认连接；</strong></p></blockquote><blockquote><p><strong>第三次握手：客户端接收到服务器端的反馈，立马发送一个ACK报文，内容为j+1，便是确认连接，这时客户端状态为establish(正常传输状态)</strong></p></blockquote><blockquote><p><strong>服务器端接收到ACK报文后，连接建立完成。</strong></p></blockquote><blockquote><h6 id="过程如下图"><a href="#过程如下图" class="headerlink" title="过程如下图"></a>过程如下图</h6></blockquote><img src="/images/threeAndFour.png" width="80%"><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>依然以客户端主动发起断开连接为例。</p><blockquote><p><strong>第一次挥手：客户端主动发起断开请求，动态生成一个序列号M，向服务器发送一个FIN报文，此时，客户端处于FIN_WAIT1状态；</strong></p></blockquote><blockquote><p><strong>第二次挥手： 服务器端收到客户端的断开请求，发送确认报文ACK(M+1)，告诉客户端，我知道了，等我处理完这波数据，此时服务器状态为CLOSE_WAIT;</strong></p></blockquote><blockquote><p><strong>第三次挥手： 等服务器处理完，准备要断开连接了，向客户端发送一个FIN报文，伴有动态生成的序列号N，此时服务器状态LAST_ACK;</strong></p></blockquote><blockquote><p><strong>第四次挥手： 客户端收到服务器发来的断开连接报文，则回复一个ACK报文N+1，表示我确认断开连接，这时客户端处于</strong> <strong><em>TIME_WAIT状态</em></strong> <strong>，很关键的状态，面试高频出现；</strong></p></blockquote><blockquote><p><strong>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</strong></p></blockquote><h6 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h6><ol><li><p><strong>TIME_WAIT状态</strong></p><pre><code>为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功收到 ACK 报文，此时处于 CLOSED 状态。</code></pre></li><li><p><strong>半连接</strong><br>  <strong>即发送了SYN包还未收到ACK确认包的连接状态为半连接状态，还未完成三次握手TCP连接。</strong></p><pre><code>半连接队列:在三次握手协议中，服务器维护一个半连接队列；该队列为每个客户端的SYN包(SYN=i)开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于SYN_ RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</code></pre></li><li><p><strong>DOS攻击</strong></p><pre><code>因为服务器会维护一个半连接的队列，那如果我们向服务器发送大量伪造的无效的半连接请求，便会消耗cpu和内存，当伪造的SYN包长时间占用半连接队列，正常的SYN请求遍会被抛弃，服务器便面临着网络阻塞甚至系统瘫痪的风险，这也是比较常见的一种DOS攻击方式。</code></pre></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> internet </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOS攻击</title>
      <link href="/2020/06/13/net-dos/"/>
      <url>/2020/06/13/net-dos/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是DOS攻击"><a href="#什么是DOS攻击" class="headerlink" title="什么是DOS攻击"></a><a href="https://baike.baidu.com/item/dos%E6%94%BB%E5%87%BB/3792374?fr=aladdin" target="_blank" rel="noopener">什么是DOS攻击</a></h3><blockquote><p>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络宽带攻击和连通性攻击。<br>说白了就是机器单挑，比谁的机器性能好、速度快<br>但是这种方式已经很远古了，毕竟计算机在迅速发展，性能也在不断提升，比如一个黑客用自己的机器，每秒钟发送10个伪装的数据包，但是被攻击的网站背后有十几台机器，每秒可以接受成百上千的数据，这时候攻击就无济于事了，反而会偷鸡不成蚀把米，自己的机器很可能会宕机。</p></blockquote><h3 id="什么是DDOS"><a href="#什么是DDOS" class="headerlink" title="什么是DDOS"></a>什么是DDOS</h3><blockquote><p>分布式拒绝服务攻击，简单说就是群殴，技术在发展，黑客也在学习，ddos就是黑客利用多台 “<strong>肉鸡</strong>”（就是可以被远程控制的多台机器），对某一网站进行攻击，可能每台机器每秒发送10个数据包，成群的 <strong>肉鸡</strong> 便可以每秒钟发出成百上千的伪装的攻击数据包，这个时候就很难抵挡了。到目前为止，防止这种攻击还是很吃力的。</p></blockquote><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><blockquote><p>我们了解了什么事dos，什么事ddos, 那么他们是怎么攻击的呢，原理是什么？？？<br>按照原理，简单来说以下几种：<br> 1.比如IP为1.1.1.1的地址是合法用户，黑客可以把自己的IP伪装成1.1.1.1，向服务器发送一个带有RST位的TCP数据段，服务器接收到之后认为该链接有错误，便会清除缓冲区建立好的连接，这时合法用户再去访问只能重新建立连接。<br> 2.向服务器发送大量的毫无用处的UDP数据包，占满带宽，导致网络可用带宽占满，最终导致服务器瘫痪。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 网络 </tag>
            
            <tag> dos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数反转</title>
      <link href="/2020/06/13/alg-reverse-integer/"/>
      <url>/2020/06/13/alg-reverse-integer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">力扣</a></p><blockquote><p>Given a 32-bit signed integer, reverse digits of an integer.<br>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>整数反转当然容易，但是要注意的是32位，溢出问题怎么处理？这里提供三种方式：<strong>String</strong>、<strong>Long</strong>、<strong>Int</strong>(<strong><em>推荐</em></strong>)</p></blockquote><h3 id="方法一：String"><a href="#方法一：String" class="headerlink" title="方法一：String"></a>方法一：String</h3><blockquote><p>利用StringBuffer 的reverse()方法，进行逆置</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public <span class="built_in">int</span> reverse(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="comment">//非负数标记，false为负数</span></span><br><span class="line">        boolean flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果x为-2147483648，-x超过Integer.MAX_VALUE</span></span><br><span class="line">            <span class="keyword">if</span>(x<span class="operator"> == </span>Integer.MIN_VALUE) &#123;</span><br><span class="line">                return <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            x = -x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果为负数，加-号</span></span><br><span class="line">        String str = flag ? <span class="keyword">new</span> <span class="constructor">StringBuffer(String.<span class="params">valueOf</span>(<span class="params">x</span>)</span>).reverse<span class="literal">()</span>.<span class="keyword">to</span><span class="constructor">String()</span> : <span class="string">"-"</span> + <span class="keyword">new</span> <span class="constructor">StringBuffer(String.<span class="params">valueOf</span>(<span class="params">x</span>)</span>).reverse<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否超过Integer值范围</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Long</span>.</span></span>value<span class="constructor">Of(<span class="params">str</span>)</span> &gt; Integer.MAX_VALUE<span class="operator"> || </span><span class="module-access"><span class="module"><span class="identifier">Long</span>.</span></span>value<span class="constructor">Of(<span class="params">str</span>)</span> &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            return <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(<span class="params">str</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：Long"><a href="#方法二：Long" class="headerlink" title="方法二：Long"></a>方法二：Long</h3><blockquote><p>用Long值存下,对long值进行反转，最后再判断范围</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> reverse(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        Long result = <span class="number">0</span>L;</span><br><span class="line">        <span class="comment">//不断的取x的最后一位，加到result后面</span></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            result = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否超过Integer值范围</span></span><br><span class="line">        <span class="keyword">if</span>(result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">int</span>Value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三：Int"><a href="#方法三：Int" class="headerlink" title="方法三：Int"></a>方法三：Int</h3><blockquote><p>以上两种方法都可以很好的解决这个问题，但是我们反思一下，或者我们来强制的加个条件，如果在运行中只能使用32位的整数，该怎么办呢？虽然现在的内存已经不宝贵了，但是我们还是要爱惜一下嘛～<br>那么更好的方法来了，这个题的关键就是输入值x在反转的过程中可能会超过int值的范围，那我们在循环的取数的时候，每次去判断下一个值是否会超过int的范围，这不就OK了</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> reverse(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//不断的取x的最后一位，加到result后面</span></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//判断是否超过Integer值范围</span></span><br><span class="line">            <span class="keyword">if</span>(result &gt; Integer.MAX_VALUE / <span class="number">10</span> || (result == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(result &lt; Integer.MIN_VALUE / <span class="number">10</span> || (result == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; Integer.MIN_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表逆置</title>
      <link href="/2020/06/12/alg-reverse-list/"/>
      <url>/2020/06/12/alg-reverse-list/</url>
      
        <content type="html"><![CDATA[<h3 id="链表逆置"><a href="#链表逆置" class="headerlink" title="链表逆置"></a>链表逆置</h3><blockquote><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p></blockquote><p>示例：</p><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><blockquote><p>头插法简单明了 <a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">code</a></p></blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        int val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(int x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode getReverseList(ListNode head) &#123;</span><br><span class="line">        <span class="comment">//定义一个空的头节点</span></span><br><span class="line">        ListNode <span class="keyword">new</span><span class="type">List</span> = <span class="keyword">new</span> <span class="type">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//定一个临时指针，指向下一个节点</span></span><br><span class="line">            ListNode nextNode = head.next;</span><br><span class="line">            <span class="comment">//断开当前节点与下一个节点连接，并接到新链表的前面</span></span><br><span class="line">            head.next = <span class="keyword">new</span><span class="type">List</span>.next;</span><br><span class="line">            <span class="comment">//当前节点插入到头节点之后（头插法）</span></span><br><span class="line">            <span class="keyword">new</span><span class="type">List</span>.next = head;</span><br><span class="line">            <span class="comment">//当前节点向后移</span></span><br><span class="line">            head = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span><span class="type">List</span>.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法查找</title>
      <link href="/2020/06/07/alg-binary/"/>
      <url>/2020/06/07/alg-binary/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>二分法查找：又称折半查找。适用于有序数据集合的目标值查找。</p></blockquote><pre><code>二分法思想：假设有一个按升序排好序的数列data，查找目标值target，过程如下：1.将数列进行折半，判断data[mid]是否等于target, 相等则返回index, 否则，判断中间值和target大小；2.若 target &gt; data[mid]，将data右一半执行第一步，否则，将data左一半执行第一步；3.返回index</code></pre><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>废话不多说，上代码</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">BinarySearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> getIndex(<span class="built_in">int</span>[] data, <span class="built_in">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> right = data.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">//定义一个中间值索引</span></span><br><span class="line">            <span class="built_in">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] == target) &#123;</span><br><span class="line">                <span class="comment">//查到目标值，直接返回索引值</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的左半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束，未找到target，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h3><blockquote><p>假如数列中出现了重复项，那我们查到的index便不确定，那如何在重复项得到最小的一个位置呢？</p></blockquote><h4 id="二分查找-顺序查找"><a href="#二分查找-顺序查找" class="headerlink" title="二分查找 + 顺序查找"></a>二分查找 + 顺序查找</h4><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">int</span> getRepeatIndex(<span class="keyword">int</span>[] <span class="title">data</span>, <span class="keyword">int</span> <span class="built_in">target</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="title">data</span>.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//这里做一改变</span></span><br><span class="line">            <span class="comment">//如果定位到目标值，不立即返回，顺序查找到最靠前的一个</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="title">data</span>[mid] == <span class="built_in">target</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (mid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="title">data</span>[mid] != <span class="built_in">target</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mid --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//循环时多-1，返回时加上</span></span><br><span class="line">                <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="title">data</span>[mid] &lt; <span class="built_in">target</span>) &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的左半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果可以找到，left则为对应的索引值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title">data</span>[left] == <span class="built_in">target</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="二分法到底"><a href="#二分法到底" class="headerlink" title="二分法到底"></a>二分法到底</h4><blockquote><p>可能大多数考虑到上述的情况就结束了，仔细想想，还可不可以更快一点儿呢，回答是肯定的</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> getRepeatIndex(<span class="built_in">int</span>[] data, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> right = data.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果数组空直接返回，防止数组越界</span></span><br><span class="line">        <span class="keyword">if</span>(data.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//'&lt;'不是'&lt;=',如果等于会出现死循环</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//关键部位！！！</span></span><br><span class="line">            <span class="comment">//保持要查到的值始终是最小索引的，二分查比顺序查要快</span></span><br><span class="line">            <span class="keyword">if</span>(data[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果可以找到，left则为对应的索引值</span></span><br><span class="line">        <span class="keyword">if</span>(data[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2020/05/20/Java/"/>
      <url>/2020/05/20/Java/</url>
      
        <content type="html"><![CDATA[<h4 id="volatile修饰"><a href="#volatile修饰" class="headerlink" title="volatile修饰"></a>volatile修饰</h4><blockquote><p>变量声明了volatile后，跳过cpu cache步骤，jvm保证每次直接从内存中读取变量</p></blockquote><ul><li>volatile声明的变量所有线程可见，即当修改一个变量值会立即更新直接更新内存，读取是也直接从内存中刷新读取</li><li>volatile声明的变量禁止指令重排序优化</li></ul><h4 id="volatile性能"><a href="#volatile性能" class="headerlink" title="volatile性能"></a>volatile性能</h4><blockquote><p>volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
